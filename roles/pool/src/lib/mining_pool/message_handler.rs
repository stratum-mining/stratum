//! # Downstream Message Handler Implementation
//!
//! Implements the `ParseMiningMessagesFromDownstream` trait for the [`Downstream`] struct.
//!
//! This module defines how the pool logic (specifically, a `Downstream` connection instance)
//! reacts to various mining-related messages received from a connected downstream miner.

use super::super::mining_pool::Downstream;
use binary_sv2::Str0255;
use roles_logic_sv2::{
    channels::server::{
        error::{ExtendedChannelError, StandardChannelError},
        extended::ExtendedChannel,
        share_accounting::{ShareValidationError, ShareValidationResult},
        standard::StandardChannel,
    },
    errors::Error,
    handlers::mining::{ParseMiningMessagesFromDownstream, SendTo, SupportedChannelTypes},
    mining_sv2::*,
    parsers::Mining,
    template_distribution_sv2::SubmitSolution,
    utils::Mutex,
};
use std::{
    convert::TryInto,
    sync::{Arc, RwLock},
};
use stratum_common::bitcoin::Amount;
use tracing::{error, info};

impl ParseMiningMessagesFromDownstream<()> for Downstream {
    // Specifies the types of mining channels supported by this pool implementation.
    //
    // Currently always returns `SupportedChannelTypes::GroupAndExtended`, indicating
    // support for both standard (grouped under a single ID) and extended channels.
    fn get_channel_type(&self) -> SupportedChannelTypes {
        SupportedChannelTypes::GroupAndExtended
    }

    // Indicates whether downstream miners are allowed to select their own work (jobs).
    fn is_work_selection_enabled(&self) -> bool {
        true
    }

    // Checks if a downstream miner is authorized based on its user identity.
    fn is_downstream_authorized(
        _self_mutex: Arc<Mutex<Self>>,
        _user_identity: &Str0255,
    ) -> Result<bool, Error> {
        Ok(true)
    }

    // Handles an `OpenStandardMiningChannel` message from the downstream miner.
    //
    // This attempts to add a new standard mining channel (or associate the request
    // with an existing group ID) using the `PoolChannelFactory`.
    //
    // Returns
    // - `Ok(SendTo::Multiple)` - Containing success messages (`OpenStandardMiningChannelSuccess`,
    //   `SetTarget`, `SetExtranoncePrefix`) generated by the factory upon successful channel setup.
    // - `Err(Error)` - If the channel factory fails to add the channel (e.g., invalid parameters,
    //   internal error, lock poisoning).
    fn handle_open_standard_mining_channel(
        &mut self,
        incoming: OpenStandardMiningChannel,
    ) -> Result<SendTo<()>, Error> {
        let request_id = incoming.get_request_id_as_u32();
        let user_identity = std::str::from_utf8(incoming.user_identity.as_ref())
            .map(|s| s.to_string())
            .map_err(|e| Error::InvalidUserIdentity(e.to_string()))?;

        info!("Received OpenStandardMiningChannel: {:?}", incoming);

        let nominal_hash_rate = incoming.nominal_hash_rate;
        let requested_max_target = incoming.max_target.into_static();

        let extranonce_prefix = self
            .extranonce_prefix_factory_standard
            .safe_lock(|factory| factory.next_prefix_standard())
            .map_err(|e| Error::PoisonLock(e.to_string()))
            .and_then(|res| res.map_err(Error::ExtranoncePrefixFactoryError))?
            .to_vec();

        let channel_id = self.channel_id_factory.next();

        let mut standard_channel = match StandardChannel::new(
            channel_id,
            user_identity,
            extranonce_prefix.clone(),
            requested_max_target.into(),
            nominal_hash_rate,
            self.share_batch_size,
            self.shares_per_minute,
        ) {
            Ok(channel) => channel,
            Err(e) => match e {
                StandardChannelError::InvalidNominalHashrate => {
                    error!("OpenMiningChannelError: invalid-nominal-hashrate");
                    let open_standard_mining_channel_error = OpenMiningChannelError {
                        request_id,
                        error_code: "invalid-nominal-hashrate"
                            .to_string()
                            .try_into()
                            .expect("error code must be valid string"),
                    };
                    return Ok(SendTo::Respond(Mining::OpenMiningChannelError(
                        open_standard_mining_channel_error,
                    )));
                }
                StandardChannelError::RequestedMaxTargetOutOfRange => {
                    error!("OpenMiningChannelError: max-target-out-of-range");
                    let open_standard_mining_channel_error = OpenMiningChannelError {
                        request_id,
                        error_code: "max-target-out-of-range"
                            .to_string()
                            .try_into()
                            .expect("error code must be valid string"),
                    };
                    return Ok(SendTo::Respond(Mining::OpenMiningChannelError(
                        open_standard_mining_channel_error,
                    )));
                }
                _ => {
                    error!("error in handle_open_standard_mining_channel: {:?}", e);
                    return Err(Error::FailedToCreateStandardChannel(e));
                }
            },
        };

        let mut messages = vec![];

        let group_channel_id = if let Some(group_channel_guard) = &self.group_channel {
            let group_channel = group_channel_guard
                .read()
                .map_err(|e| Error::PoisonLock(e.to_string()))?;
            group_channel.get_group_channel_id()
        } else {
            0
        };

        let open_standard_mining_channel_success = OpenStandardMiningChannelSuccess {
            request_id: incoming.request_id,
            channel_id,
            target: standard_channel.get_target().clone().into(),
            extranonce_prefix: standard_channel
                .get_extranonce_prefix()
                .clone()
                .try_into()
                .expect("extranonce_prefix must be valid"),
            group_channel_id,
        }
        .into_static();

        messages.push(Mining::OpenStandardMiningChannelSuccess(
            open_standard_mining_channel_success,
        ));

        let last_future_template = self.last_future_template.clone();

        // note: the fact that we're parsing a Vec<TxOut> from the config file is a bit of a hack
        // so while we don't clean that up, we only set the value of the first output
        let mut pool_coinbase_outputs = self.empty_pool_coinbase_outputs.clone();
        pool_coinbase_outputs[0].value =
            Amount::from_sat(last_future_template.coinbase_tx_value_remaining);

        // create a future standard job based on the last future template
        standard_channel
            .on_new_template(last_future_template.clone(), pool_coinbase_outputs)
            .map_err(Error::FailedToCreateStandardChannel)?;

        let future_standard_job_id = standard_channel
            .get_future_template_to_job_id()
            .get(&last_future_template.template_id)
            .expect("future job id must exist");
        let future_standard_job = standard_channel
            .get_future_jobs()
            .get(future_standard_job_id)
            .expect("future job must exist");
        let future_standard_job_message =
            future_standard_job.get_job_message().clone().into_static();

        messages.push(Mining::NewMiningJob(future_standard_job_message));

        // SetNewPrevHash message activates the future job
        let last_set_new_prev_hash_tdp = self.last_new_prev_hash.clone();
        let prev_hash = last_set_new_prev_hash_tdp.prev_hash.clone();
        let header_timestamp = last_set_new_prev_hash_tdp.header_timestamp;
        let n_bits = last_set_new_prev_hash_tdp.n_bits;
        let set_new_prev_hash_mining = SetNewPrevHash {
            channel_id,
            job_id: *future_standard_job_id,
            prev_hash,
            min_ntime: header_timestamp,
            nbits: n_bits,
        };
        standard_channel
            .on_set_new_prev_hash(last_set_new_prev_hash_tdp.clone())
            .map_err(Error::FailedToCreateStandardChannel)?;
        messages.push(Mining::SetNewPrevHash(set_new_prev_hash_mining));

        let messages = messages.into_iter().map(SendTo::Respond).collect();

        self.standard_channels
            .insert(channel_id, Arc::new(RwLock::new(standard_channel.clone())));

        if let Some(group_channel_guard) = &self.group_channel {
            let mut group_channel = group_channel_guard
                .write()
                .map_err(|e| Error::PoisonLock(e.to_string()))?;
            group_channel.add_standard_channel_id(channel_id);
        }

        Ok(SendTo::Multiple(messages))
    }

    // Handles an `OpenExtendedMiningChannel` message from the downstream miner.
    //
    // This attempts to create a new dedicated extended mining channel using the
    // `PoolChannelFactory`.
    //
    // Returns
    // - `Ok(SendTo::Multiple)` - Containing success messages (`OpenExtendedMiningChannelSuccess`,
    //   `SetTarget`, `SetExtranoncePrefix`) generated by the factory.
    // - `Err(Error)` - If the factory fails (e.g., pool doesn't support extended channels, invalid
    //   parameters, lock poisoning)
    fn handle_open_extended_mining_channel(
        &mut self,
        m: OpenExtendedMiningChannel,
    ) -> Result<SendTo<()>, Error> {
        let request_id = m.get_request_id_as_u32();
        let user_identity = std::str::from_utf8(m.user_identity.as_ref())
            .map(|s| s.to_string())
            .map_err(|e| Error::InvalidUserIdentity(e.to_string()))?;

        info!("Received OpenExtendedMiningChannel: {:?}", m);

        let nominal_hash_rate = m.nominal_hash_rate;
        let requested_max_target = m.max_target.into_static();
        let requested_min_rollable_extranonce_size = m.min_extranonce_size;

        let extranonce_prefix = match self
            .extranonce_prefix_factory_extended
            .safe_lock(|factory| {
                factory.next_prefix_extended(requested_min_rollable_extranonce_size.into())
            })
            .map_err(|e| Error::PoisonLock(e.to_string()))
            .and_then(|res| res.map_err(Error::ExtranoncePrefixFactoryError))
        {
            Ok(extranonce_prefix) => extranonce_prefix.to_vec(),
            Err(_) => {
                error!("OpenMiningChannelError: min-extranonce-size-too-large");
                let open_extended_mining_channel_error = OpenMiningChannelError {
                    request_id,
                    error_code: "min-extranonce-size-too-large"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::OpenMiningChannelError(
                    open_extended_mining_channel_error,
                )));
            }
        };

        let channel_id = self.channel_id_factory.next();

        let mut extended_channel = match ExtendedChannel::new(
            channel_id,
            user_identity,
            extranonce_prefix,
            requested_max_target.into(),
            nominal_hash_rate,
            true, // version rolling always allowed
            requested_min_rollable_extranonce_size,
            self.share_batch_size,
            self.shares_per_minute,
        ) {
            Ok(channel) => channel,
            Err(e) => match e {
                ExtendedChannelError::InvalidNominalHashrate => {
                    error!("OpenMiningChannelError: invalid-nominal-hashrate");
                    let open_extended_mining_channel_error = OpenMiningChannelError {
                        request_id,
                        error_code: "invalid-nominal-hashrate"
                            .to_string()
                            .try_into()
                            .expect("error code must be valid string"),
                    };
                    return Ok(SendTo::Respond(Mining::OpenMiningChannelError(
                        open_extended_mining_channel_error,
                    )));
                }
                ExtendedChannelError::RequestedMaxTargetOutOfRange => {
                    error!("OpenMiningChannelError: max-target-out-of-range");
                    let open_extended_mining_channel_error = OpenMiningChannelError {
                        request_id,
                        error_code: "max-target-out-of-range"
                            .to_string()
                            .try_into()
                            .expect("error code must be valid string"),
                    };
                    return Ok(SendTo::Respond(Mining::OpenMiningChannelError(
                        open_extended_mining_channel_error,
                    )));
                }
                ExtendedChannelError::RequestedMinExtranonceSizeTooLarge => {
                    error!("OpenMiningChannelError: min-extranonce-size-too-large");
                    let open_extended_mining_channel_error = OpenMiningChannelError {
                        request_id,
                        error_code: "min-extranonce-size-too-large"
                            .to_string()
                            .try_into()
                            .expect("error code must be valid string"),
                    };
                    return Ok(SendTo::Respond(Mining::OpenMiningChannelError(
                        open_extended_mining_channel_error,
                    )));
                }
                _ => {
                    error!("error in handle_open_extended_mining_channel: {:?}", e);
                    return Err(Error::FailedToCreateExtendedChannel(e));
                }
            },
        };

        let mut messages = vec![];

        let open_extended_mining_channel_success = OpenExtendedMiningChannelSuccess {
            request_id,
            channel_id,
            target: extended_channel.get_target().clone().into(),
            extranonce_prefix: extended_channel
                .get_extranonce_prefix()
                .clone()
                .try_into()?,
            extranonce_size: extended_channel.get_rollable_extranonce_size(),
        }
        .into_static();

        messages.push(Mining::OpenExtendedMiningChannelSuccess(
            open_extended_mining_channel_success,
        ));

        let last_future_template = self.last_future_template.clone();

        // note: the fact that we're parsing a Vec<TxOut> from the config file is a bit of a hack
        // so while we don't clean that up, we only set the value of the first output
        let mut pool_coinbase_outputs = self.empty_pool_coinbase_outputs.clone();
        pool_coinbase_outputs[0].value =
            Amount::from_sat(last_future_template.coinbase_tx_value_remaining);

        // create a future extended job based on the last future template
        extended_channel
            .on_new_template(last_future_template.clone(), pool_coinbase_outputs)
            .map_err(Error::FailedToCreateExtendedChannel)?;

        let future_extended_job_id = extended_channel
            .get_future_template_to_job_id()
            .get(&last_future_template.template_id)
            .expect("future job id must exist");
        let future_extended_job = extended_channel
            .get_future_jobs()
            .get(future_extended_job_id)
            .expect("future job must exist");

        let future_extended_job_message =
            future_extended_job.get_job_message().clone().into_static();

        // send this future job as new job message
        // to be immediately activated with the subsequent SetNewPrevHash message
        messages.push(Mining::NewExtendedMiningJob(future_extended_job_message));

        // SetNewPrevHash message activates the future job
        let last_set_new_prev_hash_tdp = self.last_new_prev_hash.clone();
        let prev_hash = last_set_new_prev_hash_tdp.prev_hash.clone();
        let header_timestamp = last_set_new_prev_hash_tdp.header_timestamp;
        let n_bits = last_set_new_prev_hash_tdp.n_bits;
        let set_new_prev_hash_mining = SetNewPrevHash {
            channel_id,
            job_id: *future_extended_job_id,
            prev_hash,
            min_ntime: header_timestamp,
            nbits: n_bits,
        };
        extended_channel
            .on_set_new_prev_hash(self.last_new_prev_hash.clone())
            .map_err(Error::FailedToCreateExtendedChannel)?;
        messages.push(Mining::SetNewPrevHash(set_new_prev_hash_mining));

        let messages = messages.into_iter().map(SendTo::Respond).collect();

        self.extended_channels
            .insert(channel_id, Arc::new(RwLock::new(extended_channel.clone())));

        Ok(SendTo::Multiple(messages))
    }

    // Handles an `UpdateChannel` message from the downstream miner.
    //
    // This updates the target difficulty for the specified channel based on the
    // newly provided nominal hash rate.
    //
    // Returns
    // - `Ok(SendTo::Respond)` - Containing a `SetTarget` message with the calculated new maximum
    //   target difficulty.
    // - `Err(Error)` - If calculating the target fails or the channel factory interaction fails.
    fn handle_update_channel(&mut self, m: UpdateChannel) -> Result<SendTo<()>, Error> {
        info!("Received UpdateChannel message: {:?}", m);

        let channel_id = m.channel_id;
        let new_nominal_hash_rate = m.nominal_hash_rate;
        let requested_maximum_target = m.maximum_target.into_static();

        let is_standard_channel = self.standard_channels.contains_key(&channel_id);
        let is_extended_channel = self.extended_channels.contains_key(&channel_id);

        if is_standard_channel {
            let mut standard_channel = self
                .standard_channels
                .get(&channel_id)
                .expect("standard channel must exist")
                .write()
                .map_err(|e| Error::PoisonLock(e.to_string()))?;
            let res = standard_channel
                .update_channel(new_nominal_hash_rate, Some(requested_maximum_target.into()));
            match res {
                Ok(_) => {}
                Err(e) => {
                    error!("UpdateChannelError: {:?}", e);
                    match e {
                        StandardChannelError::InvalidNominalHashrate => {
                            error!("UpdateChannelError: invalid-nominal-hashrate");
                            let update_channel_error = UpdateChannelError {
                                channel_id,
                                error_code: "invalid-nominal-hashrate"
                                    .to_string()
                                    .try_into()
                                    .expect("error code must be valid string"),
                            };
                            return Ok(SendTo::Respond(Mining::UpdateChannelError(
                                update_channel_error,
                            )));
                        }
                        StandardChannelError::RequestedMaxTargetOutOfRange => {
                            error!("UpdateChannelError: requested-max-target-out-of-range");
                            let update_channel_error = UpdateChannelError {
                                channel_id,
                                error_code: "requested-max-target-out-of-range"
                                    .to_string()
                                    .try_into()
                                    .expect("error code must be valid string"),
                            };
                            return Ok(SendTo::Respond(Mining::UpdateChannelError(
                                update_channel_error,
                            )));
                        }
                        _ => {
                            return Err(Error::FailedToUpdateStandardChannel(e));
                        }
                    }
                }
            }
            let new_target = standard_channel.get_target();
            let set_target = SetTarget {
                channel_id,
                maximum_target: new_target.clone().into(),
            };
            Ok(SendTo::Respond(Mining::SetTarget(set_target)))
        } else if is_extended_channel {
            let mut extended_channel = self
                .extended_channels
                .get(&channel_id)
                .expect("extended channel must exist")
                .write()
                .map_err(|e| Error::PoisonLock(e.to_string()))?;
            let res = extended_channel
                .update_channel(new_nominal_hash_rate, Some(requested_maximum_target.into()));
            match res {
                Ok(_) => {}
                Err(e) => {
                    error!("UpdateChannelError: {:?}", e);
                    match e {
                        ExtendedChannelError::InvalidNominalHashrate => {
                            error!("UpdateChannelError: invalid-nominal-hashrate");
                            let update_channel_error = UpdateChannelError {
                                channel_id,
                                error_code: "invalid-nominal-hashrate"
                                    .to_string()
                                    .try_into()
                                    .expect("error code must be valid string"),
                            };
                            return Ok(SendTo::Respond(Mining::UpdateChannelError(
                                update_channel_error,
                            )));
                        }
                        ExtendedChannelError::RequestedMaxTargetOutOfRange => {
                            error!("UpdateChannelError: max-target-out-of-range");
                            let update_channel_error = UpdateChannelError {
                                channel_id,
                                error_code: "max-target-out-of-range"
                                    .to_string()
                                    .try_into()
                                    .expect("error code must be valid string"),
                            };
                            return Ok(SendTo::Respond(Mining::UpdateChannelError(
                                update_channel_error,
                            )));
                        }
                        _ => {
                            return Err(Error::FailedToUpdateExtendedChannel(e));
                        }
                    }
                }
            }
            let new_target = extended_channel.get_target();
            let set_target = SetTarget {
                channel_id,
                maximum_target: new_target.clone().into(),
            };
            return Ok(SendTo::Respond(Mining::SetTarget(set_target)));
        } else {
            error!("UpdateChannelError: invalid-channel-id");
            let update_channel_error = UpdateChannelError {
                channel_id,
                error_code: "invalid-channel-id"
                    .to_string()
                    .try_into()
                    .expect("error code must be valid string"),
            };
            return Ok(SendTo::Respond(Mining::UpdateChannelError(
                update_channel_error,
            )));
        }
    }

    // Handles a `SubmitSharesStandard` message from the downstream miner.
    //
    // Validates the submitted share using the `PoolChannelFactory`. If the share is valid
    // and meets the network target, it constructs a `SubmitSolution` message and sends it
    // upstream via the `solution_sender`. Responds to the miner with `SubmitSharesSuccess`
    // or `SubmitSharesError`.
    //
    // Returns
    // - `Ok(SendTo::Respond)` - Containing either `SubmitSharesSuccess` or `SubmitSharesError`.
    // - `Err(Error)` - If the channel factory interaction fails or constructing the solution fails.
    fn handle_submit_shares_standard(
        &mut self,
        m: SubmitSharesStandard,
    ) -> Result<SendTo<()>, Error> {
        info!("Received: {:?}", m);

        let channel_id = m.channel_id;
        if !self.standard_channels.contains_key(&channel_id) {
            let submit_shares_error = SubmitSharesError {
                channel_id,
                sequence_number: m.sequence_number,
                error_code: "invalid-channel-id"
                    .to_string()
                    .try_into()
                    .expect("error code must be valid string"),
            };
            error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: invalid-channel-id âŒ", channel_id, m.sequence_number);
            return Ok(SendTo::Respond(Mining::SubmitSharesError(
                submit_shares_error,
            )));
        }

        let mut standard_channel = self
            .standard_channels
            .get(&channel_id)
            .expect("standard channel must exist")
            .write()
            .map_err(|e| Error::PoisonLock(e.to_string()))?;

        let res = standard_channel.validate_share(m.clone());
        match res {
            Ok(ShareValidationResult::Valid) => {
                info!(
                    "SubmitSharesStandard: valid share | channel_id: {}, sequence_number: {} â˜‘ï¸",
                    channel_id, m.sequence_number
                );
                Ok(SendTo::None(None))
            }
            Ok(ShareValidationResult::ValidWithAcknowledgement(
                last_sequence_number,
                new_submits_accepted_count,
                new_shares_sum,
            )) => {
                let success = SubmitSharesSuccess {
                    channel_id,
                    last_sequence_number,
                    new_submits_accepted_count,
                    new_shares_sum,
                };
                info!("SubmitSharesStandard: {:?} âœ…", success);
                Ok(SendTo::Respond(Mining::SubmitSharesSuccess(success)))
            }
            Ok(ShareValidationResult::BlockFound(template_id, coinbase)) => {
                info!("SubmitSharesStandard: ðŸ’° Block Found!!! ðŸ’°");
                // if we have a template id (i.e.: this was not a custom job)
                // we can propagate the solution to the TP
                if let Some(template_id) = template_id {
                    info!("SubmitSharesStandard: Propagating solution to the Template Provider.");
                    let solution = SubmitSolution {
                        template_id,
                        version: m.version,
                        header_timestamp: m.ntime,
                        header_nonce: m.nonce,
                        coinbase_tx: coinbase.try_into()?,
                    };
                    if self.solution_sender.try_send(solution.clone()).is_err() {
                        return Err(Error::FailedToSendSolution);
                    }
                }
                let share_accounting = standard_channel.get_share_accounting();
                let success = SubmitSharesSuccess {
                    channel_id,
                    last_sequence_number: share_accounting.get_last_share_sequence_number(),
                    new_submits_accepted_count: share_accounting.get_shares_accepted(),
                    new_shares_sum: share_accounting.get_share_work_sum(),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesSuccess(success)))
            }
            Err(ShareValidationError::Invalid) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: invalid-share âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "invalid-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            Err(ShareValidationError::Stale) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: stale-share âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "stale-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            Err(ShareValidationError::InvalidJobId) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: invalid-job-id âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "invalid-job-id"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            Err(ShareValidationError::DoesNotMeetTarget) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: difficulty-too-low âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "difficulty-too-low"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            Err(ShareValidationError::DuplicateShare) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: duplicate-share âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "duplicate-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            _ => {
                // any other error variations should never happen
                unreachable!()
            }
        }
    }

    // Handles a `SubmitSharesExtended` message from the downstream miner.
    //
    // Similar logic to `handle_submit_shares_standard`, but for extended shares.
    // Validates the share, checks against targets, sends solutions to Template Provider if
    // applicable, and responds with `SubmitSharesSuccess` or `SubmitSharesError`.
    //
    // Returns
    // - `Ok(SendTo::Respond)` - Containing either `SubmitSharesSuccess` or `SubmitSharesError`.
    // - `Err(Error)` - If the channel factory interaction fails or constructing the solution fails.
    fn handle_submit_shares_extended(
        &mut self,
        m: SubmitSharesExtended,
    ) -> Result<SendTo<()>, Error> {
        info!("Received: {:?}", m);

        let channel_id = m.channel_id;
        if !self.extended_channels.contains_key(&channel_id) {
            let error = SubmitSharesError {
                channel_id,
                sequence_number: m.sequence_number,
                error_code: "invalid-channel-id"
                    .to_string()
                    .try_into()
                    .expect("error code must be valid string"),
            };
            error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: invalid-channel-id âŒ", channel_id, m.sequence_number);
            return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
        }

        let mut extended_channel = self
            .extended_channels
            .get(&channel_id)
            .expect("extended channel must exist")
            .write()
            .map_err(|e| Error::PoisonLock(e.to_string()))?;

        let res = extended_channel.validate_share(m.clone());
        match res {
            Ok(ShareValidationResult::Valid) => {
                info!(
                    "SubmitSharesExtended: valid share | channel_id: {}, sequence_number: {} â˜‘ï¸",
                    channel_id, m.sequence_number
                );
                Ok(SendTo::None(None))
            }
            Ok(ShareValidationResult::ValidWithAcknowledgement(
                last_sequence_number,
                new_submits_accepted_count,
                new_shares_sum,
            )) => {
                let success = SubmitSharesSuccess {
                    channel_id,
                    last_sequence_number,
                    new_submits_accepted_count,
                    new_shares_sum,
                };
                info!("SubmitSharesExtended: {:?} âœ…", success);
                Ok(SendTo::Respond(Mining::SubmitSharesSuccess(success)))
            }
            Ok(ShareValidationResult::BlockFound(template_id, coinbase)) => {
                info!("SubmitSharesExtended: ðŸ’° Block Found!!! ðŸ’°");
                // if we have a template id (i.e.: this was not a custom job)
                // we can propagate the solution to the TP
                if let Some(template_id) = template_id {
                    info!("SubmitSharesExtended: Propagating solution to the Template Provider.");
                    let solution = SubmitSolution {
                        template_id,
                        version: m.version,
                        header_timestamp: m.ntime,
                        header_nonce: m.nonce,
                        coinbase_tx: coinbase.try_into()?,
                    };
                    if self.solution_sender.try_send(solution.clone()).is_err() {
                        return Err(Error::FailedToSendSolution);
                    }
                }
                let share_accounting = extended_channel.get_share_accounting();
                let success = SubmitSharesSuccess {
                    channel_id,
                    last_sequence_number: share_accounting.get_last_share_sequence_number(),
                    new_submits_accepted_count: share_accounting.get_shares_accepted(),
                    new_shares_sum: share_accounting.get_share_work_sum(),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesSuccess(success)))
            }
            Err(ShareValidationError::Invalid) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: invalid-share âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "invalid-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            Err(ShareValidationError::Stale) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: stale-share âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "stale-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            Err(ShareValidationError::InvalidJobId) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: invalid-job-id âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "invalid-job-id"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            Err(ShareValidationError::DoesNotMeetTarget) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: difficulty-too-low âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "difficulty-too-low"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            Err(ShareValidationError::DuplicateShare) => {
                error!("SubmitSharesError: channel_id: {}, sequence_number: {}, error_code: duplicate-share âŒ", channel_id, m.sequence_number);
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "duplicate-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                Ok(SendTo::Respond(Mining::SubmitSharesError(error)))
            }
            _ => {
                // any other error variations should never happen
                unreachable!()
            }
        }
    }

    // Handles a `SetCustomMiningJob` message from the downstream miner.
    //
    // This informs the `PoolChannelFactory` about the custom job details provided
    // by the miner for a specific channel.
    //
    // Returns
    // - `Ok(SendTo::Respond)` - Containing a `SetCustomMiningJobSuccess` message acknowledging the
    //   custom job setup.
    // - `Err(Error)` - If the channel factory interaction fails.
    fn handle_set_custom_mining_job(&mut self, m: SetCustomMiningJob) -> Result<SendTo<()>, Error> {
        info!("Received SetCustomMiningJob: {:?}", m);

        // this is a naive implementation, but ideally we should check the SetCustomMiningJob
        // message parameters, especially:
        // - the mining_job_token
        // - the coinbase reward outputs

        // some of these checks are actually pending on spec discussion of
        // https://github.com/stratum-mining/sv2-spec/issues/133

        let channel_id = m.channel_id;
        if !self.extended_channels.contains_key(&channel_id) {
            error!("SetCustomMiningJobError: invalid-channel-id");
            let error = SetCustomMiningJobError {
                request_id: m.request_id,
                channel_id,
                error_code: "invalid-channel-id"
                    .to_string()
                    .try_into()
                    .expect("error code must be valid string"),
            };
            return Ok(SendTo::Respond(Mining::SetCustomMiningJobError(error)));
        }

        let mut extended_channel = self
            .extended_channels
            .get(&channel_id)
            .expect("extended channel must exist")
            .write()
            .map_err(|e| Error::PoisonLock(e.to_string()))?;

        let job_id = extended_channel
            .on_set_custom_mining_job(m.clone().into_static())
            .map_err(Error::FailedToSetCustomMiningJob)?;

        let success = SetCustomMiningJobSuccess {
            channel_id,
            request_id: m.request_id,
            job_id,
        };
        Ok(SendTo::Respond(Mining::SetCustomMiningJobSuccess(success)))
    }
}
