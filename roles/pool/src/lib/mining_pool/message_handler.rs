//! # Downstream Message Handler Implementation
//!
//! Implements the `ParseMiningMessagesFromDownstream` trait for the [`Downstream`] struct.
//!
//! This module defines how the pool logic (specifically, a `Downstream` connection instance)
//! reacts to various mining-related messages received from a connected downstream miner.

use super::super::mining_pool::Downstream;
use binary_sv2::{Str0255, Sv2Option};
use roles_logic_sv2::{
    channel_management::{
        extended::factory::error::ExtendedChannelFactoryError,
        share_accounting::ShareValidationResult,
        standard::factory::error::StandardChannelFactoryError,
    },
    errors::Error,
    handlers::mining::{ParseMiningMessagesFromDownstream, SendTo, SupportedChannelTypes},
    mining_sv2::*,
    parsers::Mining,
    template_distribution_sv2::SubmitSolution,
    utils::Mutex,
};
use std::{convert::TryInto, sync::Arc};
use tracing::{debug, error, info};

impl ParseMiningMessagesFromDownstream<()> for Downstream {
    // Specifies the types of mining channels supported by this pool implementation.
    //
    // Currently always returns `SupportedChannelTypes::GroupAndExtended`, indicating
    // support for both standard (grouped under a single ID) and extended channels.
    fn get_channel_type(&self) -> SupportedChannelTypes {
        SupportedChannelTypes::GroupAndExtended
    }

    // Indicates whether downstream miners are allowed to select their own work (jobs).
    fn is_work_selection_enabled(&self) -> bool {
        true
    }

    // Checks if a downstream miner is authorized based on its user identity.
    fn is_downstream_authorized(
        _self_mutex: Arc<Mutex<Self>>,
        _user_identity: &Str0255,
    ) -> Result<bool, Error> {
        Ok(true)
    }

    // Handles an `OpenStandardMiningChannel` message from the downstream miner.
    //
    // This attempts to add a new standard mining channel (or associate the request
    // with an existing group ID) using the `PoolChannelFactory`.
    //
    // Returns
    // - `Ok(SendTo::Multiple)` - Containing success messages (`OpenStandardMiningChannelSuccess`,
    //   `SetTarget`, `SetExtranoncePrefix`) generated by the factory upon successful channel setup.
    // - `Err(Error)` - If the channel factory fails to add the channel (e.g., invalid parameters,
    //   internal error, lock poisoning).
    fn handle_open_standard_mining_channel(
        &mut self,
        incoming: OpenStandardMiningChannel,
    ) -> Result<SendTo<()>, Error> {
        let request_id = incoming.get_request_id_as_u32();
        let user_identity = std::str::from_utf8(incoming.user_identity.as_ref())
            .map(|s| s.to_string())
            .map_err(|e| Error::InvalidUserIdentity(e.to_string()))?;

        info!("Received OpenStandardMiningChannel: {:?}", incoming);
        debug!("OpenStandardMiningChannel: {:?}", incoming);

        let nominal_hash_rate = incoming.nominal_hash_rate;
        let max_target = incoming.max_target.into_static();

        // naive approach:
        // we create one group channel for the entire connection (and never really send extended
        // jobs to it) and add all standard channels to this same single group channel
        // we know this will result in _group_channel_id == 1
        // so we use that for every standard channel
        let group_channel_id = 1;

        let (standard_channel_id, target, extranonce_prefix) = match self
            .standard_channel_factory
            .new_standard_channel(user_identity, nominal_hash_rate, max_target, 1)
        {
            Ok(res) => res,
            Err(e) => match e {
                StandardChannelFactoryError::RequestedMaxTargetOutOfRange => {
                    error!("OpenMiningChannelError: max-target-out-of-range");
                    let open_standard_mining_channel_error = OpenMiningChannelError {
                        request_id,
                        error_code: "max-target-out-of-range"
                            .to_string()
                            .try_into()
                            .expect("error code must be valid string"),
                    }
                    .into_static();
                    return Ok(SendTo::Respond(Mining::OpenMiningChannelError(
                        open_standard_mining_channel_error,
                    )));
                }
                _ => {
                    error!("error in handle_open_standard_mining_channel: {:?}", e);
                    return Err(Error::StandardChannelFactoryError(e));
                }
            },
        };

        let mut messages = vec![];

        let open_standard_mining_channel_success = OpenStandardMiningChannelSuccess {
            request_id: incoming.request_id,
            group_channel_id,
            channel_id: standard_channel_id,
            target,
            extranonce_prefix: extranonce_prefix
                .try_into()
                .expect("extranonce_prefix must be valid"),
        }
        .into_static();

        messages.push(Mining::OpenStandardMiningChannelSuccess(
            open_standard_mining_channel_success,
        ));

        let standard_channel = self
            .standard_channel_factory
            .get_standard_channel(standard_channel_id)
            .expect("standard channel must exist");

        let active_job = standard_channel.get_active_job();

        if let Some(active_job) = active_job {
            let mut job_message = active_job.get_job_message().clone().into_static();

            // send this active job as future job, to be immediately activated with the subsequent
            // SetNewPrevHash message
            job_message.min_ntime = Sv2Option::new(None);
            messages.push(Mining::NewMiningJob(job_message));

            // SetNewPrevHash message activates the future job
            let chain_tip = self
                .standard_channel_factory
                .get_chain_tip()
                .map_err(Error::StandardChannelFactoryError)?;
            let set_new_prev_hash = SetNewPrevHash {
                channel_id: standard_channel_id,
                job_id: active_job.get_job_id(),
                min_ntime: chain_tip.min_ntime(),
                nbits: chain_tip.nbits(),
                prev_hash: chain_tip.prev_hash(),
            };
            messages.push(Mining::SetNewPrevHash(set_new_prev_hash));
        }

        let messages = messages.into_iter().map(SendTo::Respond).collect();

        Ok(SendTo::Multiple(messages))
    }

    // Handles an `OpenExtendedMiningChannel` message from the downstream miner.
    //
    // This attempts to create a new dedicated extended mining channel using the
    // `PoolChannelFactory`.
    //
    // Returns
    // - `Ok(SendTo::Multiple)` - Containing success messages (`OpenExtendedMiningChannelSuccess`,
    //   `SetTarget`, `SetExtranoncePrefix`) generated by the factory.
    // - `Err(Error)` - If the factory fails (e.g., pool doesn't support extended channels, invalid
    //   parameters, lock poisoning)
    fn handle_open_extended_mining_channel(
        &mut self,
        m: OpenExtendedMiningChannel,
    ) -> Result<SendTo<()>, Error> {
        let request_id = m.get_request_id_as_u32();
        let user_identity = std::str::from_utf8(m.user_identity.as_ref())
            .map(|s| s.to_string())
            .map_err(|e| Error::InvalidUserIdentity(e.to_string()))?;
        info!("Received OpenExtendedMiningChannel: {:?}", m);
        debug!("OpenExtendedMiningChannel: {:?}", m);

        let nominal_hash_rate = m.nominal_hash_rate;
        let max_target = m.max_target.into_static();
        let min_extranonce_size = m.min_extranonce_size as usize;

        let (extended_channel_id, target, rollable_extranonce_size, extranonce_prefix) =
            match self.extended_channel_factory.new_channel(
                user_identity,
                nominal_hash_rate,
                min_extranonce_size,
                max_target,
            ) {
                Ok(res) => res,
                Err(e) => match e {
                    ExtendedChannelFactoryError::RequestedMaxTargetOutOfRange => {
                        error!("OpenMiningChannelError: max-target-out-of-range");
                        let open_extended_mining_channel_error = OpenMiningChannelError {
                            request_id,
                            error_code: "max-target-out-of-range"
                                .to_string()
                                .try_into()
                                .expect("error code must be valid string"),
                        }
                        .into_static();
                        return Ok(SendTo::Respond(Mining::OpenMiningChannelError(
                            open_extended_mining_channel_error,
                        )));
                    }
                    _ => {
                        return Err(Error::ExtendedChannelFactoryError(e));
                    }
                },
            };

        let mut messages = vec![];

        let open_extended_mining_channel_success = OpenExtendedMiningChannelSuccess {
            request_id,
            channel_id: extended_channel_id,
            target,
            extranonce_size: rollable_extranonce_size,
            extranonce_prefix: extranonce_prefix
                .clone()
                .try_into()
                .expect("extranonce_prefix must be valid"),
        }
        .into_static();

        messages.push(Mining::OpenExtendedMiningChannelSuccess(
            open_extended_mining_channel_success,
        ));

        let extended_channel = self
            .extended_channel_factory
            .get_channel(extended_channel_id)
            .expect("extended channel must exist");

        let active_job = extended_channel.get_active_job();

        if let Some(active_job) = active_job {
            let mut job_message = active_job.get_job_message().clone().into_static();

            // send this active job as future job, to be immediately activated with the subsequent
            // SetNewPrevHash message
            job_message.min_ntime = Sv2Option::new(None);
            messages.push(Mining::NewExtendedMiningJob(job_message));

            // SetNewPrevHash message activates the future job
            let chain_tip = self
                .extended_channel_factory
                .get_chain_tip()
                .map_err(Error::ExtendedChannelFactoryError)?;
            let set_new_prev_hash = SetNewPrevHash {
                channel_id: extended_channel_id,
                job_id: active_job.get_job_id(),
                min_ntime: chain_tip.min_ntime(),
                nbits: chain_tip.nbits(),
                prev_hash: chain_tip.prev_hash(),
            };
            messages.push(Mining::SetNewPrevHash(set_new_prev_hash));
        }

        let messages = messages.into_iter().map(SendTo::Respond).collect();

        Ok(SendTo::Multiple(messages))
    }

    // Handles an `UpdateChannel` message from the downstream miner.
    //
    // This updates the target difficulty for the specified channel based on the
    // newly provided nominal hash rate.
    //
    // Returns
    // - `Ok(SendTo::Respond)` - Containing a `SetTarget` message with the calculated new maximum
    //   target difficulty.
    // - `Err(Error)` - If calculating the target fails or the channel factory interaction fails.
    fn handle_update_channel(&mut self, m: UpdateChannel) -> Result<SendTo<()>, Error> {
        info!("Received UpdateChannel message: {:?}", m);

        let channel_id = m.channel_id;
        let nominal_hash_rate = m.nominal_hash_rate;
        let maximum_target = m.maximum_target.into_static();

        let is_standard_channel = self
            .standard_channel_factory
            .get_standard_channel(channel_id)
            .is_ok();
        let is_extended_channel = self
            .extended_channel_factory
            .get_channel(channel_id)
            .is_ok();

        if is_standard_channel {
            let new_target = match self.standard_channel_factory.update_standard_channel(
                channel_id,
                nominal_hash_rate,
                maximum_target,
            ) {
                Ok(new_target) => new_target,
                Err(StandardChannelFactoryError::RequestedMaxTargetOutOfRange) => {
                    error!("UpdateChannelError: max-target-out-of-range");
                    let update_channel_error = UpdateChannelError {
                        channel_id,
                        error_code: "max-target-out-of-range"
                            .to_string()
                            .try_into()
                            .expect("error code must be valid string"),
                    };
                    return Ok(SendTo::Respond(Mining::UpdateChannelError(
                        update_channel_error,
                    )));
                }
                Err(e) => return Err(Error::StandardChannelFactoryError(e)),
            };
            let set_target = SetTarget {
                channel_id,
                maximum_target: new_target,
            };
            return Ok(SendTo::Respond(Mining::SetTarget(set_target)));
        } else if is_extended_channel {
            let new_target = match self.extended_channel_factory.update_channel(
                channel_id,
                nominal_hash_rate,
                maximum_target,
            ) {
                Ok(new_target) => new_target,
                Err(ExtendedChannelFactoryError::RequestedMaxTargetOutOfRange) => {
                    error!("UpdateChannelError: max-target-out-of-range");
                    let update_channel_error = UpdateChannelError {
                        channel_id,
                        error_code: "max-target-out-of-range"
                            .to_string()
                            .try_into()
                            .expect("error code must be valid string"),
                    };
                    return Ok(SendTo::Respond(Mining::UpdateChannelError(
                        update_channel_error,
                    )));
                }
                Err(e) => {
                    error!("error in handle_update_channel: {:?}", e);
                    return Err(Error::ExtendedChannelFactoryError(e));
                }
            };
            let set_target = SetTarget {
                channel_id,
                maximum_target: new_target,
            };
            return Ok(SendTo::Respond(Mining::SetTarget(set_target)));
        } else {
            error!("UpdateChannelError: invalid-channel-id");
            let update_channel_error = UpdateChannelError {
                channel_id,
                error_code: "invalid-channel-id"
                    .to_string()
                    .try_into()
                    .expect("error code must be valid string"),
            };
            return Ok(SendTo::Respond(Mining::UpdateChannelError(
                update_channel_error,
            )));
        }
    }

    // Handles a `SubmitSharesStandard` message from the downstream miner.
    //
    // Validates the submitted share using the `PoolChannelFactory`. If the share is valid
    // and meets the network target, it constructs a `SubmitSolution` message and sends it
    // upstream via the `solution_sender`. Responds to the miner with `SubmitSharesSuccess`
    // or `SubmitSharesError`.
    //
    // Returns
    // - `Ok(SendTo::Respond)` - Containing either `SubmitSharesSuccess` or `SubmitSharesError`.
    // - `Err(Error)` - If the channel factory interaction fails or constructing the solution fails.
    fn handle_submit_shares_standard(
        &mut self,
        m: SubmitSharesStandard,
    ) -> Result<SendTo<()>, Error> {
        info!("Received SubmitSharesStandard: {:?}", m);
        debug!("SubmitSharesStandard {:?}", m);

        match self.standard_channel_factory.validate_share(m.clone()) {
            Ok(ShareValidationResult::Valid) => {
                info!("SubmitSharesStandard: valid share");
                Ok(SendTo::None(None))
            }
            Ok(ShareValidationResult::ValidWithAcknowledgement(
                last_sequence_number,
                new_submits_accepted_count,
                new_shares_sum,
            )) => {
                let success = SubmitSharesSuccess {
                    channel_id: m.channel_id,
                    last_sequence_number,
                    new_submits_accepted_count,
                    new_shares_sum,
                };
                info!(
                    "SubmitSharesStandard: valid share with acknowledgement {:?}",
                    success
                );
                return Ok(SendTo::Respond(Mining::SubmitSharesSuccess(success)));
            }
            Ok(ShareValidationResult::BlockFound(template_id, coinbase)) => {
                info!("SubmitSharesStandard: 💰 Block Found!!! 💰");
                // if we have a template id (i.e.: this was not a custom job)
                // we can propagate the solution to the TP
                if let Some(template_id) = template_id {
                    info!("SubmitSharesStandard: Propagating solution to the Template Provider.");
                    let solution = SubmitSolution {
                        template_id,
                        version: m.version,
                        header_timestamp: m.ntime,
                        header_nonce: m.nonce,
                        coinbase_tx: coinbase.try_into()?,
                    };
                    if self.solution_sender.try_send(solution.clone()).is_err() {
                        return Err(Error::FailedToSendSolution);
                    }
                }
                Ok(SendTo::None(None))
            }
            Err(StandardChannelFactoryError::InvalidShare) => {
                error!("SubmitSharesStandard: invalid share");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "invalid-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(StandardChannelFactoryError::StaleShare) => {
                error!("SubmitSharesStandard: stale share");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "stale-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(StandardChannelFactoryError::InvalidJobId) => {
                error!("SubmitSharesStandard: invalid job id");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "invalid-job-id"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(StandardChannelFactoryError::ShareDoesNotMeetTarget) => {
                error!("SubmitSharesStandard: share does not meet target");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "difficulty-too-low"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(StandardChannelFactoryError::DuplicateShare) => {
                error!("SubmitSharesStandard: duplicate share");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "duplicate-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(e) => Err(Error::StandardChannelFactoryError(e)),
        }
    }

    // Handles a `SubmitSharesExtended` message from the downstream miner.
    //
    // Similar logic to `handle_submit_shares_standard`, but for extended shares.
    // Validates the share, checks against targets, sends solutions to Template Provider if
    // applicable, and responds with `SubmitSharesSuccess` or `SubmitSharesError`.
    //
    // Returns
    // - `Ok(SendTo::Respond)` - Containing either `SubmitSharesSuccess` or `SubmitSharesError`.
    // - `Err(Error)` - If the channel factory interaction fails or constructing the solution fails.
    fn handle_submit_shares_extended(
        &mut self,
        m: SubmitSharesExtended,
    ) -> Result<SendTo<()>, Error> {
        info!(
            "Received SubmitSharesExtended from downstream_id: {}, channel_id: {}, message: {:?}",
            self.id, m.channel_id, m
        );
        debug!("SubmitSharesExtended {:?}", m);

        match self
            .extended_channel_factory
            .validate_share(m.clone().into_static())
        {
            Ok(ShareValidationResult::Valid) => {
                info!("SubmitSharesExtended: valid share");
                Ok(SendTo::None(None))
            }
            Ok(ShareValidationResult::ValidWithAcknowledgement(
                last_sequence_number,
                new_submits_accepted_count,
                new_shares_sum,
            )) => {
                let success = SubmitSharesSuccess {
                    channel_id: m.channel_id,
                    last_sequence_number,
                    new_submits_accepted_count,
                    new_shares_sum,
                };
                info!(
                    "SubmitSharesExtended: valid share with acknowledgement {:?}",
                    success
                );
                return Ok(SendTo::Respond(Mining::SubmitSharesSuccess(success)));
            }
            Ok(ShareValidationResult::BlockFound(template_id, coinbase)) => {
                info!("SubmitSharesExtended: 💰 Block Found!!! 💰");
                // if we have a template id (i.e.: this was not a custom job)
                // we can propagate the solution to the TP
                if let Some(template_id) = template_id {
                    info!("SubmitSharesExtended: Propagating solution to the Template Provider.");
                    let solution = SubmitSolution {
                        template_id,
                        version: m.version,
                        header_timestamp: m.ntime,
                        header_nonce: m.nonce,
                        coinbase_tx: coinbase.try_into()?,
                    };
                    if self.solution_sender.try_send(solution.clone()).is_err() {
                        return Err(Error::FailedToSendSolution);
                    }
                }
                Ok(SendTo::None(None))
            }
            Err(ExtendedChannelFactoryError::InvalidShare) => {
                error!("SubmitSharesExtended: invalid share");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "invalid-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(ExtendedChannelFactoryError::StaleShare) => {
                error!("SubmitSharesExtended: stale share");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "stale-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(ExtendedChannelFactoryError::InvalidJobId) => {
                error!("SubmitSharesExtended: invalid job id");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "invalid-job-id"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(ExtendedChannelFactoryError::ShareDoesNotMeetTarget) => {
                error!("SubmitSharesExtended: share does not meet target");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "difficulty-too-low"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(ExtendedChannelFactoryError::DuplicateShare) => {
                error!("SubmitSharesExtended: duplicate share");
                let error = SubmitSharesError {
                    channel_id: m.channel_id,
                    sequence_number: m.sequence_number,
                    error_code: "duplicate-share"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SubmitSharesError(error)));
            }
            Err(e) => Err(Error::ExtendedChannelFactoryError(e)),
        }
    }

    // Handles a `SetCustomMiningJob` message from the downstream miner.
    //
    // This informs the `PoolChannelFactory` about the custom job details provided
    // by the miner for a specific channel.
    //
    // Returns
    // - `Ok(SendTo::Respond)` - Containing a `SetCustomMiningJobSuccess` message acknowledging the
    //   custom job setup.
    // - `Err(Error)` - If the channel factory interaction fails.
    fn handle_set_custom_mining_job(&mut self, m: SetCustomMiningJob) -> Result<SendTo<()>, Error> {
        info!(
            "Received SetCustomMiningJob message for channel: {}, with id: {}",
            m.channel_id, m.request_id
        );
        debug!("SetCustomMiningJob: {:?}", m);

        // ideally we should also check the token, but this is a naive implementation

        let expected_coinbase_reward_outputs = self.pool_coinbase_outputs.clone();

        match self.extended_channel_factory.process_set_custom_mining_job(
            m.clone().into_static(),
            expected_coinbase_reward_outputs,
        ) {
            Ok(job_id) => {
                info!("SetCustomMiningJob OK, job_id: {:?}", job_id);
                let success: SetCustomMiningJobSuccess = SetCustomMiningJobSuccess {
                    channel_id: m.channel_id,
                    request_id: m.request_id,
                    job_id,
                };
                return Ok(SendTo::Respond(Mining::SetCustomMiningJobSuccess(success)));
            }
            Err(ExtendedChannelFactoryError::CustomMiningJobBadChannelId) => {
                error!("SetCustomMiningJobError: invalid-channel-id");
                let error = SetCustomMiningJobError {
                    channel_id: m.channel_id,
                    request_id: m.request_id,
                    error_code: "invalid-channel-id"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SetCustomMiningJobError(error)));
            }
            Err(ExtendedChannelFactoryError::CustomMiningJobBadPrevHash) => {
                error!("SetCustomMiningJobError: invalid-job-param-value-prev-hash");
                let error = SetCustomMiningJobError {
                    channel_id: m.channel_id,
                    request_id: m.request_id,
                    error_code: "invalid-job-param-value-prev-hash"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SetCustomMiningJobError(error)));
            }
            Err(ExtendedChannelFactoryError::CustomMiningJobBadNbits) => {
                error!("SetCustomMiningJobError: invalid-job-param-value-nbits");
                let error = SetCustomMiningJobError {
                    channel_id: m.channel_id,
                    request_id: m.request_id,
                    error_code: "invalid-job-param-value-nbits"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SetCustomMiningJobError(error)));
            }
            Err(ExtendedChannelFactoryError::CustomMiningJobBadNtime) => {
                error!("SetCustomMiningJobError: invalid-job-param-value-ntime");
                let error = SetCustomMiningJobError {
                    channel_id: m.channel_id,
                    request_id: m.request_id,
                    error_code: "invalid-job-param-value-ntime"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SetCustomMiningJobError(error)));
            }
            Err(ExtendedChannelFactoryError::CustomMiningJobBadCoinbaseRewardOutputs) => {
                error!("SetCustomMiningJobError: invalid-job-param-value-coinbase-tx-outputs");
                let error = SetCustomMiningJobError {
                    channel_id: m.channel_id,
                    request_id: m.request_id,
                    error_code: "invalid-job-param-value-coinbase-tx-outputs"
                        .to_string()
                        .try_into()
                        .expect("error code must be valid string"),
                };
                return Ok(SendTo::Respond(Mining::SetCustomMiningJobError(error)));
            }
            Err(e) => Err(Error::ExtendedChannelFactoryError(e)),
        }
    }
}
