// # Initiator Role
//
// Manages the [`Initiator`] role in the Noise protocol handshake for communication between Sv2
// roles. The initiator is responsible for starting the handshake process by sending the first
// cryptographic message to the [`crate::Responder`] role (e.g., a mining pool).
//
// The [`Initiator`] role is equipped with utilities for generating and managing the initiator's
// key pairs, performing elliptic curve Diffie-Hellman (ECDH) key exchanges, and encrypting
// messages during the handshake phase. The initiator's responsibilities include:
//
// - Generating an ephemeral key pair for the handshake.
// - Using the [`secp256k1`] elliptic curve for ECDH to derive a shared secret.
// - Encrypting the initial handshake message to securely exchange cryptographic material.
// - Managing the state transitions between handshake steps, including updating the handshake hash,
//   chaining key, and encryption key as the session progresses.
//
// ## Usage
// The initiator role is typically used by a downstream Sv2 role (e.g., a local mining proxy) to
// establish a secure connection with an upstream responder (e.g., a remote mining pool). The
// initiator begins the handshake by generating a public key and sending it to the responder. After
// receiving a response, the initiator computes a shared secret and encrypts further messages using
// this key.
//
// The [`Initiator`] struct implements the [`HandshakeOp`] trait, which defines the core
// cryptographic operations during the handshake. It ensures secure communication by supporting
// both the [`ChaCha20Poly1305`] or `AES-GCM` cipher, providing both confidentiality and message
// authentication for all subsequent communication.
//
// ### Secure Data Erasure
//
// The [`Initiator`] includes functionality for securely erasing sensitive cryptographic material,
// ensuring that private keys and other sensitive data are wiped from memory when no longer needed.
//
// The [`Drop`] trait is implemented to automatically trigger secure erasure when the [`Initiator`]
// instance goes out of scope, preventing potential misuse or leakage of cryptographic material.

use alloc::{
    boxed::Box,
    string::{String, ToString},
};
use core::{convert::TryInto, ptr};

use crate::{
    cipher_state::{Cipher, CipherState, GenericCipher},
    error::Error,
    handshake::HandshakeOp,
    signature_message::SignatureNoiseMessage,
    NoiseCodec, ELLSWIFT_ENCODING_SIZE, ENCRYPTED_ELLSWIFT_ENCODING_SIZE,
    ENCRYPTED_SIGNATURE_NOISE_MESSAGE_SIZE, INITIATOR_EXPECTED_HANDSHAKE_MESSAGE_SIZE,
    SIGNATURE_NOISE_MESSAGE_SIZE,
};
use aes_gcm::KeyInit;
use chacha20poly1305::ChaCha20Poly1305;
use secp256k1::{
    ellswift::{ElligatorSwift, ElligatorSwiftParty},
    Keypair, PublicKey, XOnlyPublicKey,
};

/// Manages the initiator's role in the Noise NX handshake, handling key exchange, encryption, and
/// handshake state. It securely generates and manages cryptographic keys, performs Diffie-Hellman
/// exchanges, and maintains the handshake hash, chaining key, and nonce for message encryption.
/// After the handshake, it facilitates secure communication using either [`ChaCha20Poly1305`] or
/// `AES-GCM` ciphers. Sensitive data is securely erased when no longer needed.
#[derive(Clone)]
pub struct Initiator {
    // Cipher used for encrypting and decrypting messages during the handshake.
    //
    // It is initialized once enough information is available from the handshake process.
    handshake_cipher: Option<ChaCha20Poly1305>,
    // Optional static key used in the handshake. This key may be derived from the pre-shared key
    // (PSK) or generated during the handshake.
    k: Option<[u8; 32]>,
    // Current nonce used in the encryption process.
    //
    // Ensures that the same plaintext encrypted twice will produce different ciphertexts.
    n: u64,
    // Chaining key used in the key derivation process to generate new keys throughout the
    // handshake.
    ck: [u8; 32],
    // Handshake hash which accumulates all handshake messages to ensure integrity and prevent
    // tampering.
    h: [u8; 32],
    // Ephemeral key pair generated by the initiator for this session, used for generating the
    // shared secret with the responder.
    e: Keypair,
    // Optional public key of the responder, used to authenticate the responder during the
    // handshake.
    #[allow(unused)]
    responder_authority_pk: Option<XOnlyPublicKey>,
    // First [`CipherState`] used for encrypting messages from the initiator to the responder
    // after the handshake is complete.
    c1: Option<GenericCipher>,
    // Second [`CipherState`] used for encrypting messages from the responder to the initiator
    // after the handshake is complete.
    c2: Option<GenericCipher>,
}

impl core::fmt::Debug for Initiator {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        f.debug_struct("Initiator").finish()
    }
}

// Ensures that the `Cipher` type is not `Sync`, which prevents multiple threads from
// simultaneously accessing the same instance of `Cipher`. This eliminates the need to handle
// potential issues related to visibility of changes across threads.
//
// After sending the `k` value, we immediately clear it to prevent the original thread from
// accessing the value again, thereby enhancing security by ensuring the sensitive data is no
// longer available in memory.
//
// The `Cipher` struct is neither `Sync` nor `Copy` due to its `cipher` field, which implements
// the `AeadCipher` trait. This trait requires mutable access, making the entire struct non-`Sync`
// and non-`Copy`, even though the key and nonce are simple types.
impl CipherState<ChaCha20Poly1305> for Initiator {
    fn get_k(&mut self) -> &mut Option<[u8; 32]> {
        &mut self.k
    }

    fn get_n(&self) -> u64 {
        self.n
    }

    fn set_n(&mut self, n: u64) {
        self.n = n;
    }

    fn get_cipher(&mut self) -> &mut Option<ChaCha20Poly1305> {
        &mut self.handshake_cipher
    }

    fn set_k(&mut self, k: Option<[u8; 32]>) {
        self.k = k;
    }
}

impl HandshakeOp<ChaCha20Poly1305> for Initiator {
    fn name(&self) -> String {
        "Initiator".to_string()
    }

    fn get_h(&mut self) -> &mut [u8; 32] {
        &mut self.h
    }

    fn get_ck(&mut self) -> &mut [u8; 32] {
        &mut self.ck
    }

    fn set_h(&mut self, data: [u8; 32]) {
        self.h = data;
    }

    fn set_ck(&mut self, data: [u8; 32]) {
        self.ck = data;
    }

    fn set_handshake_cipher(&mut self, cipher: ChaCha20Poly1305) {
        self.handshake_cipher = Some(cipher);
    }
}

impl Initiator {
    /// Creates a new [`Initiator`] instance with an optional responder public key.
    ///
    /// If the responder public key is provided, the initiator uses this key to authenticate the
    /// responder during the handshake. The initial initiator state is instantiated with the
    /// ephemeral key pair and handshake hash.
    #[cfg(feature = "std")]
    pub fn new(pk: Option<XOnlyPublicKey>) -> Box<Self> {
        Self::new_with_rng(pk, &mut rand::thread_rng())
    }

    /// Creates a new [`Initiator`] instance with an optional responder public key and a custom
    /// random number generator.
    ///
    /// See [`Self::new`] for more details.
    ///
    /// The custom random number generator is used to generate the ephemeral key pair. It should be
    /// provided in order to not implicitely rely on `std` and allow `no_std` environments to
    /// provide a hardware random number generator for example.
    #[inline]
    pub fn new_with_rng<R: rand::Rng + ?Sized>(
        pk: Option<XOnlyPublicKey>,
        rng: &mut R,
    ) -> Box<Self> {
        let mut self_ = Self {
            handshake_cipher: None,
            k: None,
            n: 0,
            ck: [0; 32],
            h: [0; 32],
            e: Self::generate_key_with_rng(rng),
            responder_authority_pk: pk,
            c1: None,
            c2: None,
        };
        self_.initialize_self();
        Box::new(self_)
    }

    /// Creates a new [`Initiator`] instance using a raw 32-byte public key.
    ///
    /// Constructs a [`XOnlyPublicKey`] from the provided raw key slice and initializes a new
    /// [`Initiator`] with the derived public key. If the provided key cannot be converted into a
    /// valid [`XOnlyPublicKey`], an [`Error::InvalidRawPublicKey`] error is returned.
    ///
    /// Typically used when the initiator is aware of the responder's public key in advance.
    #[cfg(feature = "std")]
    pub fn from_raw_k(key: [u8; 32]) -> Result<Box<Self>, Error> {
        Self::from_raw_k_with_rng(key, &mut rand::thread_rng())
    }

    /// Creates a new [`Initiator`] instance using a raw 32-byte public key and a custom random
    /// number generator.
    ///
    /// See [`Self::from_raw_k`] for more details.
    ///
    /// The custom random number generator should be provided in order to not implicitely rely on
    /// `std` and allow `no_std` environments to provide a hardware random number generator for
    /// example.
    #[inline]
    pub fn from_raw_k_with_rng<R: rand::Rng + ?Sized>(
        key: [u8; 32],
        rng: &mut R,
    ) -> Result<Box<Self>, Error> {
        let pk =
            secp256k1::XOnlyPublicKey::from_slice(&key).map_err(|_| Error::InvalidRawPublicKey)?;
        Ok(Self::new_with_rng(Some(pk), rng))
    }

    /// Creates a new [`Initiator`] without requiring the responder's authority public key.
    /// This function initializes the [`Initiator`] with a default empty state and is intended
    /// for use when both the initiator and responder are within the same network. In this case,
    /// the initiator does not validate the responder's static key from a certificate. However,
    /// the connection remains encrypted.
    #[cfg(feature = "std")]
    pub fn without_pk() -> Result<Box<Self>, Error> {
        Self::without_pk_with_rng(&mut rand::thread_rng())
    }

    /// Creates a new [`Initiator`] instance without a responder's public key and using a custom
    /// random number generator.
    ///
    /// See [`Self::without_pk`] for more details.
    ///
    /// The custom random number generator should be provided in order to not implicitely rely on
    /// `std` and allow `no_std` environments to provide a hardware random number generator for
    /// example.
    #[inline]
    pub fn without_pk_with_rng<R: rand::Rng + ?Sized>(rng: &mut R) -> Result<Box<Self>, Error> {
        Ok(Self::new_with_rng(None, rng))
    }

    /// Executes the initial step of the Noise NX protocol handshake.
    ///
    /// This step involves generating an ephemeral keypair and encoding the public key using
    /// Elligator Swift encoding, which obscures the key to prevent identification. The encoded
    /// public key is then mixed into the handshake state, and an empty payload is encrypted.
    /// This operation currently only affects the handshake hash, as the key (`k`) is not yet
    /// established. The function returns the encoded public key, which is ready to be sent to
    /// the responder.
    ///
    /// On success, the function returns a 64-byte array containing the encoded public key.
    /// If an error occurs during encryption, it returns an [`aes_gcm::Error`].
    pub fn step_0(&mut self) -> Result<[u8; ELLSWIFT_ENCODING_SIZE], aes_gcm::Error> {
        let elliswift_enc_pubkey = ElligatorSwift::from_pubkey(self.e.public_key()).to_array();
        self.mix_hash(&elliswift_enc_pubkey);
        self.encrypt_and_hash(&mut vec![])?;

        let mut message = [0u8; ELLSWIFT_ENCODING_SIZE];
        message[..64].copy_from_slice(&elliswift_enc_pubkey[..ELLSWIFT_ENCODING_SIZE]);
        Ok(message)
    }

    /// Processes the second step of the Noise NX protocol handshake for the initiator.
    ///
    /// This method handles the responder's reply in the Noise NX protocol handshake, processing
    /// the message to derive shared secrets and authenticate the responder. It interprets the
    /// first 64 bytes of the message as the responder's ephemeral public key, decodes it, and
    /// mixes it into the handshake state. It then derives a shared secret from the ephemeral keys
    /// and updates the state accordingly.
    ///
    /// The next 80 bytes of the message contain the responder's static public key, encrypted and
    /// authenticated. The method decrypts this segment and derives another shared secret using the
    /// responder's static public key, further securing the handshake state. Finally, the method
    /// decrypts and verifies the signature included in the message to ensure the responder's
    /// authenticity.
    ///
    /// On success, this method returns a [`NoiseCodec`] instance initialized with session ciphers
    /// for secure communication. If the provided `message` has an incorrect length, it returns an
    /// [`Error::InvalidMessageLength`]. If decryption or signature verification fails, it returns
    /// an [`Error::InvalidCertificate`].
    #[cfg(feature = "std")]
    pub fn step_2(
        &mut self,
        message: [u8; INITIATOR_EXPECTED_HANDSHAKE_MESSAGE_SIZE],
    ) -> Result<NoiseCodec, Error> {
        let now = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs() as u32;
        self.step_2_with_now(message, now)
    }

    /// Processes the second step of the Noise NX protocol handshake for the initiator given the
    /// current system time.
    ///
    /// See [`Self::step_2`] for more details.
    ///
    /// The current system time should be provided to avoid relying on `std` and allow `no_std`
    /// environments to use another source of time.
    pub fn step_2_with_now(
        &mut self,
        message: [u8; INITIATOR_EXPECTED_HANDSHAKE_MESSAGE_SIZE],
        now: u32,
    ) -> Result<NoiseCodec, Error> {
        // 2. interprets first 64 bytes as ElligatorSwift encoding of x-coordinate of public key
        // from this is derived the 32-bytes remote ephemeral public key `re.public_key`
        let mut elliswift_theirs_ephemeral_serialized: [u8; ELLSWIFT_ENCODING_SIZE] =
            [0; ELLSWIFT_ENCODING_SIZE];
        elliswift_theirs_ephemeral_serialized.clone_from_slice(&message[0..ELLSWIFT_ENCODING_SIZE]);
        self.mix_hash(&elliswift_theirs_ephemeral_serialized);

        // 3. calls `MixHash(re.public_key)`
        // 4. calls `MixKey(ECDH(e.private_key, re.public_key))`
        let e_private_key = self.e.secret_key();
        let elligatorswift_ours_ephemeral = ElligatorSwift::from_pubkey(self.e.public_key());
        let elligatorswift_theirs_ephemeral =
            ElligatorSwift::from_array(elliswift_theirs_ephemeral_serialized);
        let ecdh_ephemeral: [u8; 32] = ElligatorSwift::shared_secret(
            elligatorswift_ours_ephemeral,
            elligatorswift_theirs_ephemeral,
            e_private_key,
            ElligatorSwiftParty::A,
            None,
        )
        .to_secret_bytes();
        self.mix_key(&ecdh_ephemeral);

        // 5. decrypts next 80 bytes with `DecryptAndHash()` and stores the results as
        // `rs.public_key` which is **server's static public key** (note that 64 bytes is the
        // elligatorswift encoded public key and 16 bytes is MAC)
        let mut to_decrypt = message
            [ELLSWIFT_ENCODING_SIZE..ELLSWIFT_ENCODING_SIZE + ENCRYPTED_ELLSWIFT_ENCODING_SIZE]
            .to_vec();
        self.decrypt_and_hash(&mut to_decrypt)?;

        // 6. calls `MixKey(ECDH(e.private_key, rs.public_key)`
        let elligatorswift_theirs_static_serialized: [u8; ELLSWIFT_ENCODING_SIZE] = to_decrypt[..]
            .try_into()
            .expect("slice with incorrect length");
        let elligatorswift_theirs_static =
            ElligatorSwift::from_array(elligatorswift_theirs_static_serialized);
        let ecdh_static: [u8; 32] = ElligatorSwift::shared_secret(
            elligatorswift_ours_ephemeral,
            elligatorswift_theirs_static,
            e_private_key,
            ElligatorSwiftParty::A,
            None,
        )
        .to_secret_bytes();
        self.mix_key(&ecdh_static);

        // Decrypt and verify the SignatureNoiseMessage
        let mut to_decrypt = message[ELLSWIFT_ENCODING_SIZE + ENCRYPTED_ELLSWIFT_ENCODING_SIZE
            ..INITIATOR_EXPECTED_HANDSHAKE_MESSAGE_SIZE]
            .to_vec();
        if to_decrypt.len() != ENCRYPTED_SIGNATURE_NOISE_MESSAGE_SIZE {
            return Err(Error::InvalidMessageLength);
        }

        self.decrypt_and_hash(&mut to_decrypt)?;
        let plaintext: [u8; SIGNATURE_NOISE_MESSAGE_SIZE] = to_decrypt.try_into().unwrap();
        let signature_message: SignatureNoiseMessage = plaintext.into();
        let rs_pub_key = PublicKey::from_ellswift(elligatorswift_theirs_static)
            .x_only_public_key()
            .0
            .serialize();
        let rs_pk_xonly = XOnlyPublicKey::from_slice(&rs_pub_key).unwrap();
        if signature_message.verify_with_now(&rs_pk_xonly, &self.responder_authority_pk, now) {
            let (temp_k1, temp_k2) = Self::hkdf_2(self.get_ck(), &[]);
            let c1 = ChaCha20Poly1305::new(&temp_k1.into());
            let c2 = ChaCha20Poly1305::new(&temp_k2.into());
            let c1: Cipher<ChaCha20Poly1305> = Cipher::from_key_and_cipher(temp_k1, c1);
            let c2: Cipher<ChaCha20Poly1305> = Cipher::from_key_and_cipher(temp_k2, c2);
            self.c1 = None;
            self.c2 = None;
            let mut encryptor = GenericCipher::ChaCha20Poly1305(c1);
            let mut decryptor = GenericCipher::ChaCha20Poly1305(c2);
            encryptor.erase_k();
            decryptor.erase_k();
            let codec = crate::NoiseCodec {
                encryptor,
                decryptor,
            };
            Ok(codec)
        } else {
            Err(Error::InvalidCertificate(plaintext))
        }
    }

    // Securely erases sensitive data from the [`Initiator`] memory.
    //
    // Clears all sensitive cryptographic material within the [`Initiator`] to prevent any
    // accidental leakage or misuse. It overwrites the stored keys, chaining key, handshake hash,
    // and session ciphers with zeros. This method is typically
    // called when the [`Initiator`] instance is no longer needed or before deallocation.
    fn erase(&mut self) {
        if let Some(k) = self.k.as_mut() {
            for b in k {
                unsafe { ptr::write_volatile(b, 0) };
            }
        }
        for mut b in self.ck {
            unsafe { ptr::write_volatile(&mut b, 0) };
        }
        for mut b in self.h {
            unsafe { ptr::write_volatile(&mut b, 0) };
        }
        if let Some(c1) = self.c1.as_mut() {
            c1.erase_k()
        }
        if let Some(c2) = self.c2.as_mut() {
            c2.erase_k()
        }
        self.e.non_secure_erase();
    }
}
impl Drop for Initiator {
    fn drop(&mut self) {
        self.erase();
    }
}
